--[[ 

    This simple game script i made features:
    - Longer and harder obstacle course with 6 sections
    - Advanced dynamic obstacles (spinning, moving, scaling, and disappearing parts)
    - Leaderboard for points with checkpoints
    - Custom player respawn logic at checkpoints
    - End game logic with winner announcement
--]]

-- 📦 SERVICES 📦
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local Workspace = game.Workspace
local RunService = game:GetService("RunService")

-- 🛠️ SETTINGS 🛠️
local START_POSITION = Vector3.new(0, 5, 0) -- Start of the obstacle course
local FINISH_LINE = Vector3.new(600, 5, 0) -- End of the obstacle course
local POINTS_PER_CHECKPOINT = 10 -- Points for completing checkpoints
local RESPAWN_DELAY = 3 -- Time to respawn a player after falling

-- Organize game objects into folders
local Checkpoints = Instance.new("Folder", Workspace)
Checkpoints.Name = "Checkpoints"

local Obstacles = Instance.new("Folder", Workspace)
Obstacles.Name = "Obstacles"

-- 📊 PLAYER LEADERBOARD 📊
local function setupLeaderboard(player)
    local leaderstats = Instance.new("Folder")
    leaderstats.Name = "leaderstats"
    leaderstats.Parent = player

    local points = Instance.new("IntValue")
    points.Name = "Points"
    points.Value = 0
    points.Parent = leaderstats

    -- Store checkpoint for respawn logic
    local currentCheckpoint = Instance.new("Vector3Value")
    currentCheckpoint.Name = "CurrentCheckpoint"
    currentCheckpoint.Value = START_POSITION
    currentCheckpoint.Parent = player
end

-- 🔄 CREATE SPINNING OBSTACLE 🔄
local function createSpinningPart(position, size, spinSpeed)
    local part = Instance.new("Part")
    part.Size = size
    part.Position = position
    part.Anchored = true
    part.BrickColor = BrickColor.new("Bright red")
    part.Material = Enum.Material.SmoothPlastic
    part.Parent = Obstacles

    -- Continuously rotate the part
    local spinDirection = CFrame.Angles(0, math.rad(spinSpeed), 0)
    RunService.Stepped:Connect(function()
        part.CFrame = part.CFrame * spinDirection
    end)

    return part
end

-- 🔄 CREATE MOVING OBSTACLE 🔄
local function createMovingPart(startPos, endPos, size, moveTime)
    local part = Instance.new("Part")
    part.Size = size
    part.Position = startPos
    part.Anchored = true
    part.BrickColor = BrickColor.new("Bright blue")
    part.Material = Enum.Material.Neon
    part.Parent = Obstacles

    -- Tween the part back and forth
    local tweenInfo = TweenInfo.new(moveTime, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, -1, true)
    local goal = {Position = endPos}
    local tween = TweenService:Create(part, tweenInfo, goal)
    tween:Play()

    return part
end

-- 🔄 CREATE SCALING OBSTACLE 🔄
local function createScalingPart(position, initialSize, scaleMultiplier, scaleTime)
    local part = Instance.new("Part")
    part.Size = initialSize
    part.Position = position
    part.Anchored = true
    part.BrickColor = BrickColor.new("Bright green")
    part.Material = Enum.Material.SmoothPlastic
    part.Parent = Obstacles

    -- Tween the size of the part
    local tweenInfo = TweenInfo.new(scaleTime, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
    local goal = {Size = initialSize * scaleMultiplier}
    local tween = TweenService:Create(part, tweenInfo, goal)
    tween:Play()

    return part
end

-- 🔄 CREATE DISAPPEARING OBSTACLE 🔄
local function createDisappearingPart(position, size, disappearTime)
    local part = Instance.new("Part")
    part.Size = size
    part.Position = position
    part.Anchored = true
    part.BrickColor = BrickColor.new("Bright orange")
    part.Material = Enum.Material.SmoothPlastic
    part.Parent = Obstacles

    -- Make the part disappear and reappear periodically
    while true do
        wait(disappearTime)
        part.Transparency = 1
        part.CanCollide = false
        wait(disappearTime)
        part.Transparency = 0
        part.CanCollide = true
    end
end

-- ✅ CREATE CHECKPOINTS ✅
local function createCheckpoint(position, checkpointIndex)
    local checkpoint = Instance.new("Part")
    checkpoint.Size = Vector3.new(10, 1, 10)
    checkpoint.Position = position
    checkpoint.Anchored = true
    checkpoint.BrickColor = BrickColor.new("Bright yellow")
    checkpoint.Name = "Checkpoint" .. checkpointIndex
    checkpoint.Parent = Checkpoints

    -- Add checkpoint logic
    checkpoint.Touched:Connect(function(hit)
        local player = Players:GetPlayerFromCharacter(hit.Parent)
        if player then
            -- Update the player's current checkpoint
            local currentCheckpoint = player:FindFirstChild("CurrentCheckpoint")
            if currentCheckpoint then
                currentCheckpoint.Value = position
            end

            -- Award points for reaching the checkpoint
            local points = player:FindFirstChild("leaderstats"):FindFirstChild("Points")
            if points and checkpoint:GetAttribute("Activated") ~= true then
                points.Value += POINTS_PER_CHECKPOINT
                checkpoint:SetAttribute("Activated", true)
                print(player.Name .. " earned " .. POINTS_PER_CHECKPOINT .. " points!")
            end
        end
    end)
end

-- 🚀 PLAYER RESPAWN LOGIC 🚀
Players.PlayerAdded:Connect(function(player)
    setupLeaderboard(player)

    player.CharacterAdded:Connect(function(character)
        -- Respawn the player at their last checkpoint
        local currentCheckpoint = player:FindFirstChild("CurrentCheckpoint")
        if currentCheckpoint then
            wait(RESPAWN_DELAY)
            character:MoveTo(currentCheckpoint.Value)
        end
    end)
end)

-- 🛠️ BUILD EXTENDED OBSTACLE COURSE 🛠️
local function buildCourse()
    -- SECTION 1: Spinning Obstacles
    createSpinningPart(Vector3.new(20, 5, 0), Vector3.new(10, 1, 10), 2)
    createSpinningPart(Vector3.new(40, 5, 0), Vector3.new(10, 1, 10), -3)
    createCheckpoint(Vector3.new(60, 6, 0), 1)

    -- SECTION 2: Moving Platforms
    createMovingPart(Vector3.new(80, 5, -5), Vector3.new(80, 5, 5), Vector3.new(10, 1, 10), 2)
    createMovingPart(Vector3.new(100, 5, -5), Vector3.new(100, 5, 5), Vector3.new(10, 1, 10), 3)
    createCheckpoint(Vector3.new(120, 6, 0), 2)

    -- SECTION 3: Scaling Platforms
    createScalingPart(Vector3.new(140, 5, 0), Vector3.new(10, 1, 10), 1.5, 2)
    createScalingPart(Vector3.new(160, 5, 0), Vector3.new(10, 1, 10), 2, 3)
    createCheckpoint(Vector3.new(180, 6, 0), 3)

    -- SECTION 4: Gaps with Spinning Bars
    createSpinningPart(Vector3.new(200, 5, 0), Vector3.new(20, 1, 1), 5)
    createSpinningPart(Vector3.new(230, 5, 0), Vector3.new(20, 1, 1), -5)
    createCheckpoint(Vector3.new(250, 6, 0), 4)

    -- SECTION 5: Disappearing Platforms
    createDisappearingPart(Vector3.new(270, 5, 0), Vector3.new(10, 1, 10), 2)
    createDisappearingPart(Vector3.new(290, 5, 0), Vector3.new(10, 1, 10), 3)
    createCheckpoint(Vector3.new(310, 6, 0), 5)

    -- SECTION 6: Final Stretch with Mixed Obstacles
    createMovingPart(Vector3.new(330, 5, -5), Vector3.new(330, 5, 5), Vector3.new(10, 1, 10), 2)
    createScalingPart(Vector3.new(360, 5, 0), Vector3.new(10, 1, 10), 1.5, 2)
    createSpinningPart(Vector3.new(390, 5, 0), Vector3.new(10, 1, 10), 4)
    createCheckpoint(FINISH_LINE, 6)
end

-- Build the course
buildCourse()

-- 🎯 END GAME LOGIC 🎯
local function endGame()
    print("Game Over! Tallying results...")
    local topPlayer = nil
    local topPoints = 0

    for _, player in ipairs(Players:GetPlayers()) do
        local points = player:FindFirstChild("leaderstats"):FindFirstChild("Points")
        if points and points.Value > topPoints then
            topPoints = points.Value
            topPlayer = player
        end
    end

    if topPlayer then
        print("Winner: " .. topPlayer.Name .. " with " .. topPoints .. " points!")
    else
        print("No winner this time!")
    end
end

-- Run the game
task.wait(180) -- Run the game for 3 minutes
endGame()
